pragma solidity ^0.4.4;

/*
This contract is vulnerable to Reentrance.  That is, if an attacker
contract calls this code, it is possible for their code to take 
control and access functions within the Reentrance contract

When `msg.sender.call.value(amountToWithdraw)()` is called,
if `msg.sender` is a payable contract, it will invoke their
fall back function immediately before finishing the rest of the
execution.

The fallback function can simply call withdraw again, and again,
and since the balances are updated after the call.value()(),
the Reentrance contract permits it.
*/

// INSECURE
contract Reentrance {
    mapping(address => uint) public shares;
    
    function Reentrance() payable public {
        shares[msg.sender] += msg.value;
    }
    
    // Deposit to contract
    function deposit() payable public {
    	shares[msg.sender] += msg.value;
    }

    // Withdraw your share
    // BUG: Allows contracts invoking this function to make extra calls before shares[msg.sender] is updated
    function withdraw() public {
        uint amountToWithdraw = shares[msg.sender];
        msg.sender.call.value(amountToWithdraw)(); // At this point, the caller's code is executed, and can call withdraw again
        shares[msg.sender] = 0;
    }

    // added to simplify testing
    function getBalance() constant public returns(uint) {
        return this.balance;
    }
}