var Auction = artifacts.require("./Auction.sol");
var AuctionAttacker = artifacts.require("./AuctionAttacker.sol");


contract('Auction', function(accounts) {
	it ("should be able to function as normal when standard accounts are being used", function() {
		return Auction.deployed().then(function(instance) {
			AuctionInstance = instance;

			// load the contract up with funds
			return AuctionInstance.bid({from: accounts[0], value: 2000});
		}).then(function() {
			return AuctionInstance.getHighestBid();
		}).then(function(highestBid) {
			// make sure they value went through
			assert.equal(highestBid, 2000, "highest bid does not update to bid");
			return AuctionInstance.getCurrentLeader();
		}).then(function(currentLeader) {
			assert.equal(currentLeader, accounts[0]);
			// account 1 outbids
			return AuctionInstance.bid({from: accounts[1], value: 3000});
		}).then(function() {
			return AuctionInstance.getHighestBid();
		}).then(function(highestBid){
			// highest bid should be 3000 now
			assert.equal(highestBid, 3000);
			return AuctionInstance.getCurrentLeader();
		}).then(function(currentLeader) {
			// account 1 should be leader now
			assert.equal(currentLeader, accounts[1]);
		});
	});

	it ("should fail to let anyone else bids after the attacker", function() {
		return Auction.deployed().then(function(instance) {
			AuctionInstance = instance;
			return AuctionAttacker.deployed().then(function(instance) {
				AttackerInstance = instance;

				return AttackerInstance.bidExternal(AuctionInstance.address, {from: accounts[2], value: 3200});
			}).then(function() {
				// Attacker contract should now be leader
				return AuctionInstance.getCurrentLeader();
			}).then(function(currentLeader) {
				assert.equal(currentLeader, AttackerInstance.address);
				// *-----------------------------------------------*
				// Uncomment the line below to see that the attacker can't be outbid, causes VM exception for bid attempt
				return AuctionInstance.bid({from: accounts[0], value: 5000});
			});
		});
	});
});